---
title: 归并算法
categories: 
	- 学习
tags: 
	- PTA
cover: https://s2.ax1x.com/2019/11/01/KbApL9.jpg
---

# 快乐的源泉


<img src="https://s2.ax1x.com/2019/11/01/KbApL9.jpg"  title="快乐的源泉为什么不能是学习呢"/>

<br/>
<br/>

## 有困难，但熬过去就好了

😉记得要看到最后!!!

```
#include<stdio.h>
#include<stdlib.h>
void merge(int a[], int start, int mid, int end)
{
    int i, j, k, n1, n2;
    int * front, * back; //变量用于申请两个内存空间

    n1 = mid - start + 1;   //前一序列长度
    n2 = end - mid;         //后一序列长度

    //申请两个空间存放两个序列值
    front = (int *) malloc (n1 * sizeof(int)) ; 
    back = (int *) malloc (n2 * sizeof(int));

    //将值设置到新序列中
    for (i = 0; i < n1; i++)
    {
        front[i] = a[start + i];     //start+i的start不是一直都为0的，故不可缺
    }
    for (i = 0; i < n2; i++)
    {
        back[i] = a[mid + i + 1];  //同start
    }

    //将元素合并
    i = 0;
    j = 0;
    k = start;
    // i j 指针分别指向两个新序列的起始位置
    while (i < n1 && j < n2)
    {
        if (front[i] < back[j])
        {
            a[k++] = front[i++];
        }
        else
        {
            a[k++] = back[j++];
        }
    }   

   //合并剩余元素 
    while (i < n1)     // 有点巧妙
    {
        a[k++] = front[i++];
    }
    while (j < n2)
    {
        a[k++] = back[j++];
    }
}

void sort(int a[], int start, int end)
{
    int mid;
    if (start < end)
    {
        mid = (start + end) / 2;  // 分解成两个序列
        sort(a, start, mid); // 递归将左边序列分解到子问题
        sort(a, mid + 1, end); // 递归将右边序列分解到子问题
        merge(a, start, mid, end);  // 合并子问题的解
    }
}
int main()
{
    int a[8] = {1, 4, 3, 9, 6, 5, 8, 7};
    int i;

    sort(a, 0, 7);

    for (i = 0; i < 8; i++)
    {
        printf("%d\t", a[i]);
    }
    printf("\n");
    return 0;
}
```


![](https://s2.ax1x.com/2019/09/23/uC55G9.png)



## Java版本
先看一个合并两个有序数组到目标数组的程序：

```
import java.util.Arrays;

public class MergeSort {
    
    private void mergeArray(int[] a, int start, int[] one, int[] two) {
        int oneLen = one.length;
        int twoLen = two.length;

        // m 指针指向 one数组, n 指针指向two数组
        int m = 0, n = 0;
        // i 指针指向 a数组
        int i = start;
        while (m < oneLen && n < twoLen) {
            if (one[m] < two[n]) {
                a[i] = one[m];
                m++;
            } else {
                a[i] = two[n];
                n++;
            }
            i++;
        }

        while (m < oneLen) {
            a[i] = one[m];
            i++;
            m++;
        }

        while (n < twoLen) {
            a[i] = two[n];
            i++;
            n++;
        }
    }

    public static void main(String[] args) {
        MergeSort mergeSort = new MergeSort();
        int a[] = new int[12];
        int[] one = new int[]{1, 16, 80, 200, 201};
        int[] two = new int[]{10, 32, 45, 79, 90, 100, 101};
        mergeSort.mergeArray(a, 0, one, two);
        System.out.println(Arrays.toString(a));
    }
}
```

更符合人类思维习惯的Java版本：
```
import java.util.Arrays;

public class MergeSort {
    private void mergeArray(int[] a, int start, int[] one, int[] two) {
        int oneLen = one.length;
        int twoLen = two.length;

        // m 指针指向 one数组, n 指针指向two数组
        int m = 0, n = 0;
        // i 指针指向 a数组
        int i = start;
        while (m < oneLen && n < twoLen) {
            if (one[m] < two[n]) {
                a[i] = one[m];
                m++;
            } else {
                a[i] = two[n];
                n++;
            }
            i++;
        }

        while (m < oneLen) {
            a[i] = one[m];
            i++;
            m++;
        }

        while (n < twoLen) {
            a[i] = two[n];
            i++;
            n++;
        }
    }

    private void merge(int[] a, int start, int mid, int end) {
        int frontLen = mid - start + 1;
        int backLen = end - mid;
        int[] front = new int[frontLen];
        int[] back = new int[backLen];
        // 初始化front和back数组
        for (int i = 0; i < frontLen; i++) {
            front[i] = a[start + i];
        }
        for (int i = 0; i < backLen; i++) {
            back[i] = a[mid + 1 + i];
        }
        mergeArray(a, start, front, back);
    }

    public void sort(int[] a, int start, int end) {
        if (start < end) {
            int mid = (start + end) / 2;
            sort(a, start, mid);
            sort(a, mid + 1, end);
            merge(a, start, mid, end);
        }
    }

    public static void main(String[] args) {
        MergeSort mergeSort = new MergeSort();
        int[] a = {1, 4, 3, 9, 6, 5, 8, 7};
        mergeSort.sort(a, 0, 7);
        System.out.println(Arrays.toString(a));
    }
}
```


<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

---

<br/>
<br/>
<br/>
<br/>
<br/>
<br/>

# 算是掌握了这个问题的代码了 


7-2 找第k小的数 (30 分)
设计一个平均时间为O(n)的算法，在n(1<=n<=1000)个无序的整数中找出第k小的数。

提示：函数int partition(int a[],int left,int right)的功能是根据a[left]\~a[right]中的某个元素x（如a[left])对a[left]\~a[right]进行划分，划分后的x所在位置的左段
全小于等于x,右段全大于等于x,同时利用x所在的位置还可以计算出x是这批数据按升非降序排列的第几个数。因此可以编制int find(int a[],int left,int right,int k)函数，
通过调用partition函数获得划分点，判断划分点是否第k小，若不是，递归调用find函数继续在左段或右段查找。

输入格式:
输入有两行：

第一行是n和k，0<k<=n<=10000

第二行是n个整数

输出格式:
输出第k小的数

输入样例:
```
10 4
2 8 9 0 1 3 6 7 8 2
```

输出样例:
```
2
```


问题是要O(n)的问题,但这归并好像是O(nlogn)的......  


```
#include <iostream>
using namespace std;
int arr[1000],aux[1000];  // 默认全为 0 

void merge(int arr[],int l,int m,int r)
{
	for(int i=l;i<=r;i++)  // " i<=r " 有个等于号,因为 r=n-1  
	aux[i]=arr[i];
		
	int i = l , j = m + 1 , k = l;
	while(i<=m && j<=r)
	{
		if(aux[i]<aux[j]) 
			arr[k++] = aux[i++];
		else 
			arr[k++] = aux[j++];
	}
	
	while(i>m && j<=r) arr[k++] = aux[j++];    
	// 括号内少了 " && j<=r " 会出错,直接没有结果输出
	
	while(j>r && i<=m) arr[k++] = aux[i++];
	// 同上  (尚未搞懂为什么)
}

void mergesort(int arr[],int l,int r)
{
	if(l<r)
	{
		int m=(l+r)/2;
		mergesort(arr,l,m);
		mergesort(arr,m+1,r);
		merge(arr,l,m,r);
	}
}

int main()
{
	int n,k;
	cin>>n;
	cin>>k;
	
	for(int i=0;i<n;i++)
	{
		cin>>arr[i];	
	}
	
	int l=0,r=n-1;
	mergesort(arr,l,r);
	
	cout<<arr[k - 1];   // k-1 注意下 
	
	return 0;
 } 
 
O(nlogn)
```

# sort()函数的应用 

使用库里的函数sort()同样可以解决问题，但注意包含头文件**#include <algorithm>**  

```
#include <iostream>
using namespace std;
#include <algorithm>
int main()
{
	int n,k;
	cin>>n>>k;
	
	int arr[n];
	for(int i=0;i<n;i++)
		cin>>arr[i];
		
	sort(arr,arr+10);
	cout<<arr[k-1];
	
	return 0;
}

O(nlogn)
```

